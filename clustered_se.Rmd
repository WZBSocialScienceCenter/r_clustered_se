---
title: 'Clustered standard errors with R: Three ways, one result'
author: "Markus Konrad"
date: "`r Sys.Date()`"
bibliography: ["bibliography.bib"]
link-citations: true
output:
  bookdown::html_document2: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# output.lines option hack from https://stackoverflow.com/a/23205752
library(knitr)
hook_output <- knit_hooks$get("output")
knit_hooks$set(output = function(x, options) {
   lines <- options$output.lines
   if (is.null(lines)) {
     return(hook_output(x, options))  # pass to default hook
   }
   x <- unlist(strsplit(x, "\n"))
   more <- "..."
   if (length(lines)==1) {        # first n lines
     if (length(x) > lines) {
       # truncate the output, but add ....
       x <- c(head(x, lines), more)
     }
   } else {
     x <- c(if (abs(lines[1])>1) more else NULL, 
            x[lines], 
            if (length(x)>lines[abs(length(lines))]) more else NULL
           )
   }
   # paste these lines together
   x <- paste(c(x, ""), collapse = "\n")
   hook_output(x, options)
 })
```

## Introduction {-}

TODO

## Data {-}

We'll work with the dataset *nlswork* that's [included in Stata](https://www.stata-press.com/data/r16/), so we can easily compare the results with Stata. The data comes from the US National Longitudinal Survey (NLS) and contains information about more than 4,000 young working women. As for this example, we're interested in the relationship between wage (here as log-scaled GNP-adjusted wage) as dependent variable (DV) `ln_wage` and survey participant's current `age`, job `tenure` in years and `union` membership as independent variables. It's a longitudinal survey, so subjects were asked repeatedly between 1968 and 1988 and each subject is identified by an unique `idcode`.

The example data is used for illustrative purposes only and we skip many things that we'd normally do, such as investigating descriptive statistics and exploratory plots. To keep the data size limited, we'll only work with a subset of the data (only subjects with IDs 1 to 100) and we also simply dismiss any observations that contain missing values.

```{r, warning=FALSE, error=FALSE, message=FALSE}
library(webuse)
library(dplyr)

#nlswork_orig <- webuse('nlswork')
nlswork_orig <- readRDS('cache/nlswork.RDS')

nlswork <- filter(nlswork_orig, idcode <= 100) %>%
  select(idcode, year, ln_wage, age, tenure, union) %>%
  filter(complete.cases(.)) %>%
  mutate(union = as.integer(union),
         idcode = as.factor(idcode))
str(nlswork)
```
Let's have a look at the first few observations. They contain data from subject #1, who was surveyed several times between 1972 and 1988, and a few observations from subject #2.

```{r}
head(nlswork, 10)
```

```{r}
summary(nlswork)
```

We have 82 subjects in our subset:

```{r}
length(unique(nlswork$idcode))
```
The number of times each subject was surveyed ranges from only once to twelve times:

```{r}
summary(as.integer(table(nlswork$idcode)))
```
In more than one quarter of the observations, the subject answered to be currently member of a trade union:

```{r}
table(nlswork$union)
```

The following shows the distribution of the DV in our data.

```{r}
hist(nlswork$ln_wage, breaks = 20, main = 'Histogram of DV', xlab = NA)
```
The DV is roughly normally distributed with the following mean and SD:

```{r}
c(mean(nlswork$ln_wage), sd(nlswork$ln_wage))
```
We can calculate the mean and SD of the DV separately for each subject. A histogram of these subject-specific means reveals more variability:

```{r}
y_mean_sd_cl <- sapply(levels(nlswork$idcode), function(idcode) {
  y_cl <- nlswork$ln_wage[nlswork$idcode == idcode]
  c(mean(y_cl), sd(y_cl))
})
hist(y_mean_sd_cl[1,], breaks = 20, main = 'Histogram of DV means per subject', xlab = NA)
```

We can compare the SD of the subject-specific means with the mean of the SDs calculated from each subjects' repeated measures.

```{r}
c(sd(y_mean_sd_cl[1,]), mean(y_mean_sd_cl[2,], na.rm = TRUE))
```
The SD between the subject-specific means is almost twice as large as the mean of the SD from each subjects' values. This shows that there's much more variability between each subject than within each subject's repeated measures.


## Fixed-effects model, not adjusting for clustered observations {-}

Our data contains repeated measures for each subject, so we have panel data in which each subject forms a group or cluster. We can use a fixed-effects (FE) model to account for unobserved subject-specific characteristics. We do so by including the subject's `idcode` in our model formula.  It's important to note that `idcode` is of type factor (we applied `idcode = as.factor(idcode)` when we prepared the data) so that for each factor level (i.e. each subject) an FE coefficient will be estimated that represents the subject-specific mean of our DV. (Please note that it is not always necessary to use an FE model and you can estimate robust SEs from clustered data also without FEs.)

Let's specify and fit such a model using `lm`. We include job `tenure`, `union` membership and an interaction between both (the latter mainly for illustrative purposes later when we estimate marginal effects). We also control for `age` and add `idcode` as FE variable.

```{r, output.lines=20}
m1 <- lm(ln_wage ~ age + tenure + union + tenure:union + idcode,
         data = nlswork)
summary(m1)
```
We're not really interested in the subject-specific means (the FE coefficients), so let's filter them out and only show our coefficients of interest:

```{r}
m1coeffs_std <- data.frame(summary(m1)$coefficients)
coi_indices <- which(!startsWith(row.names(m1coeffs_std), 'idcode'))
m1coeffs_std[coi_indices,]
```

Unsurprisingly, job tenure and especially union membership are positively associated with wage. (Please note the cautious language here, since we can't make any causal claims with our very simplified approach.) The coefficient of the interaction term shows that with union membership the job tenure effect is even a bit higher, though not significantly.

In the next two sections we'll see how standard errors for our estimates are usually computed and how this fits into a framework called "sandwich estimators." Using this framework, we see how the standard error calculations can be adjusted to give consistent results for clustered data.

## Standard errors {-}

In ordinary least squares (OLS) regression, we assume that the regression model errors are independent. This is not the case here: Each subject may be surveyed several times so within each subject's repeated measures, the errors will be correlated. Although that is not a problem for our regression estimates (they are still unbiased â€“ [@roberts_robust_2013]), it *is* a problem for for the precision of our estimates -- the precision will typically be overestimated, i.e. the standard errors (SEs) will be lower than they should be [@zeileis_various_2020, @cameron_practitioners_2013]. The intuition behind this for our example is that within our clusters we usually have lower variance since the answers come from the same subject and are correlated with each other. This lowers our estimates' SEs.

We can deal with this using *clustered standard errors* with subjects representing our clusters. But before we do this, let's first have a closer look on how "classical" OLS estimates' SEs our actually computed.

In matrix notation, a linear model has the form

$$
Y = X\beta + e.
$$
This model has $p$ parameters (including the intercept parameter $\beta_0$) expressed as $p \times 1$ parameter vector $\beta$ and is estimated from $n$ observations in our data. The DV is $Y$ (an $n \times 1$ vector), the independent variables form an $n \times p$ matrix $X$. Finally, the error term $e$ is an $n \times 1$ vector that captures everything that influences $Y$ but cannot be explained by $X\beta$.

By minimizing $e = Y - X\beta$, an estimation for our parameters, $\hat\beta$, can be found. @roberts_robust_2013 shows how the estimated variance of the parameter estimates $\hat V[\hat\beta]$ can be derived which results in the *sandwich estimator*

\begin{equation} 
\hat V[\hat\beta] = (X^TX)^{-1} X^T \boldsymbol\Omega X (X^TX)^{-1}.
(\#eq:sandwich)
\end{equation} 


This is called sandwich estimator because of the structure of the formula: Between two slices of bread $(X^TX)^{-1}$ there is the meat $X^T \boldsymbol\Omega X$ and this is the most important part for us, because we can see how it relates to the computation of the SEs. One of the classic OLS assumptions is [constant variance (or homoscedasticity)](https://bookdown.org/roback/bookdown-BeyondMLR/ch-MLRreview.html#assumptions-for-linear-least-squares-regression) in the errors across the full spectrum of our DV. This implicates that $\Omega$ is a diagonal matrix with identical $\hat\sigma^2$ elements. That simplifies the above equation to

\begin{equation} 
\hat V[\hat\beta] = \hat\sigma^2 (X^TX)^{-1}.
(\#eq:classicalvar)
\end{equation} 

We're almost finished with estimating the standard errors for a classic OLS model. What's left is the *residual variance* $\hat\sigma^2$. This is calculated as

$$
\hat\sigma^2 = \frac{\sum^n_{i=1} \hat e_i^2}{n-p},
$$
with $\hat e_i$ being the residuals. The numerator is also called the *residual sum of squares* and the denominator is the *degrees of freedom*.

Let's replicate the standard errors from model `m1` with our own calculations. To translate these formulae to R, we use `model.matrix()` to get the design matrix $X$, `nobs()` for number of observations $n$, `ncol(X)` for the number or parameters, `solve()` to calculate the inverse of $X^T X$ and `diag()` to extract the diagonal of square matrix.

```{r, output.lines=3}
X <- model.matrix(m1)
u <- residuals(m1)     # \hat e
n <- nobs(m1)
p <- ncol(X)
sigma2 <- sum(u^2) / (n - p)
crossXinv <- solve(t(X) %*% X, diag(p))
m1se <- sqrt(diag(sigma2 * crossXinv))
m1se
```
Let's check if this is equal to the standard errors calculated by `lm()` (using `near()` because of minor deviations due to floating point precision):

```{r}
all(near(m1se, m1coeffs_std$Std..Error))
```

## Clustered standard errors {-}

We took our parameter estimates variance $\hat V[\hat\beta]$ from the diagonal of the *variance-covariance (vcov) matrix*  and R has the `vcov()` function to calculate it from a fitted model. It's exactly what we computed before using eq. 2:

```{r}
all(near(sigma2 * crossXinv, vcov(m1)))
```

The square root of the diagonal in the vcov matrix is the SEs of our parameter estimates. Instead of the simplified form in eq. 2, we can use different estimators for the vcov matrix that are based on the sandwich estimator in eq. 1. The trick with sandwich estimators is that you can exchange the bread and meat of your sandwich according to the structure of your data. This allows you to arrive at consistent SEs even when some of the OLS assumptions like homoscedasticity are violated. This is the "versatile" part in the  @zeileis_various_2020 paper dubbed *"Various Versatile Variances."* When we want to obtain clustered SEs, we need to consider that $\Omega$ in the "meat" part of eq. 1 is *not* a diagonal matrix with identical $\hat\sigma^2$ elements anymore, hence this can't be simplified to eq. 2. Instead, we can assume that $\Omega$ is block-diagonal with the clusters forming the blocks. This means, we assume that the variance in the errors is constant *within clusters* and so we first calculate $\Omega_j$ per cluster $j$ and then sum the $\Omega_j$. @cameron_practitioners_2013 (p. 11) shows how $\Omega$ is calculated in detail and also which finite-sample correction factor is applied. From this article we get the equation

\begin{equation} 
\Omega = \frac{n-1}{n-p}\frac{c}{c-1} \sum_{j=1}^c (X_j^T \hat e_j \hat e_j^T X_j),
(\#eq:omegacl)
\end{equation} 

where $c$ is the number of clusters.

Let's translate this to R. We already have $\hat e$ as `u` (the residuals) and the design matrix `X`. We can generate a list of $\Omega_j$, sum them and multiply the correction factor:

```{r}
omegaj <- lapply(levels(nlswork$idcode), function(idcode) {
  j <- nlswork$idcode == idcode
  X_j <- X[j, , drop = FALSE]           # don't drop dimensions when we have only one obs.
  t(X_j) %*% tcrossprod(u[j]) %*% X_j   # tcrossprod is outer product x * x^T
})

n_cl <- length(levels(nlswork$idcode))  # num. clusters
#                 correction factor          *   sum of omega_j
omega <- (n-1) / (n - p) * (n_cl / (n_cl-1)) * Reduce('+', omegaj)
# sandwich formula; extract diagonal and take square root to get SEs
m1clse <- sqrt(diag(crossXinv %*% omega %*% crossXinv))   
m1clse[1:5]   # only showing the first 5 values here
```
We will later check that this matches the estimates calculated with R packages that implement clustered SE estimation. For now let's compare the classic OLS SEs with the clustered SEs:

```{r}
m1coeffs_with_clse <- cbind(m1coeffs_std, CLSE = m1clse)
m1coeffs_with_clse[coi_indices,]
```
We can see that, as expected, the clustered SEs are all a bit higher than the classic OLS SEs.

---

The above calculations were used to show what's happening "under the hood" and also how the formulas used for these calculations are motivated. However, doing the above calculations "by hand" is error-prone and slow. It's better to use well trusted packages for daily work and so next we'll have a look at some of these packages and how they can be used. Still, it's helpful to understand some background and the limitations for this approach. See @cameron_practitioners_2013 for a much more thorough guide (though only with examples in Stata) that also considers topics like which variable(s) to user for clustering, what to do with low number of clusters or how to implement multi-way clustering.

## Option 1: *sandwich* and *lmtest* {-}

The [*sandwich* package](https://cran.r-project.org/web/packages/sandwich/index.html) implements several methods for robust covariance estimators, including clustered SEs. Details are explained in the already mentioned paper by @zeileis_various_2020. The accompanying [*lmtest* package](https://cran.r-project.org/web/packages/lmtest/index.html) then provides functions for coefficient tests that take into account the calculated robust covariance estimates.

As explained initially, the parameter estimates from our model are consistent despite the clustered structure of our data. Only the SEs are biased downward and need to be corrected. This is why we can resume to work with our initially estimated model `m1` from `lm()`. There's no need to refit it and sandwich works with lm model objects (and also some other types of models such as some glm models). We only have to adjust how we test our coefficient estimates in the following way:

1. We need to use [`coeftest()`](https://rdrr.io/cran/lmtest/man/coeftest.html) from the lmtest package;
2. we need to pass either a function to calculate the covariance matrix or an already estimated covariance matrix to the `vcov` parameter;
3. we need to specify a cluster variable in the `cluster` parameter.

TODO continue here

sandwich provides several vcov func., we use vcovCL ...

- acts on model from `lm`
- `vcov` either takes a vcov mat or a function to calculate a vcov mat from `lm` object; here, use `vcovCL` function from sandwich
- `cluster` takes the variable(s) to cluster on (either as formula or string vector)

```{r, warning=FALSE, message=FALSE}
library(sandwich)
library(lmtest)

m1coeffs_cl <- coeftest(m1, vcov = vcovCL, cluster = ~idcode)     # , fix = TRUE ?
m1coeffs_cl[coi_indices,]
```

- calc. 95%-CIs:

```{r}
coefci(m1, parm = coi_indices, vcov = vcovCL, cluster = ~idcode)
```
- important to "drag along" the vcov and cluster parameters, otherwise CIs for unadjusted model are calculated
- here, `tenure` and `union` CIs suddenly do not include zero

```{r}
coefci(m1, parm = coi_indices)
```

- we can also first calculate the vcov mat for clustered SEs and then pass this matrix to all further functions that we need

```{r}
cl_vcov_mat <- vcovCL(m1, cluster = ~idcode)
```

- this time we pass the vcov matrix
- result is the same

```{r}
m1coeffs_cl2 <- coeftest(m1, vcov = cl_vcov_mat)
m1coeffs_cl2[coi_indices,]
```
- same for CIs:

```{r}
coefci(m1, parm = coi_indices, vcov = cl_vcov_mat)
```

- calculate marginal effects: pass vcov matrix

```{r, warning=FALSE}
library(margins)

margins(m1, vcov = cl_vcov_mat, variables = 'tenure', at = list(union = 0:1)) %>% summary()
```

- forgetting the vcov matrix:

```{r}
margins(m1, variables = 'tenure', at = list(union = 0:1)) %>% summary()
```

## Option 2: `lm.cluster` from *miceadds* {-}

- once again a strange package name
- additional functionality for imputation with *mice* package
- happens to contain a function for clustered SE, `lm.cluster`
- basically does the same as we've done before by using sandwich's `vcovCL` (see source https://github.com/alexanderrobitzsch/miceadds/blob/ca9e54c18e9743280b9a075e6e119fec38693af2/R/lm.cluster.R#L33 and https://github.com/alexanderrobitzsch/miceadds/blob/ca9e54c18e9743280b9a075e6e119fec38693af2/R/lm_cluster_compute_vcov.R#L13)
- only a bit more convenient maybe

```{r, warning=FALSE}
library(miceadds)

m2 <- lm.cluster(ln_wage ~ age + tenure + union + tenure:union + idcode,
                 cluster = 'idcode',
                 data = nlswork)
m2coeffs <- data.frame(summary(m2))
m2coeffs[!startsWith(row.names(m2coeffs), 'idcode'),]
```

- p-value for intercept is different; dunno why
- returned object from `lm.cluster` is a list that contains the `lm` object as `lmres` and the vcov matrix as `vcov`
- again, these objects need to be "dragged along"
- we also need to pass data again via `data = nlswork`

```{r}
margins(m2$lm_res, vcov = m2$vcov, variables = 'tenure', at = list(union = 0:1), data = nlswork) %>% summary()
```
- the result is consistent with our former computations

## Option 3: `lm_robust` from *estimatr* {-}

- reference to DeclareDesign framework
- https://declaredesign.org/r/estimatr/articles/getting-started.html#lm_robust

```{r}
library(estimatr)

m3 <- lm_robust(ln_wage ~ age + tenure + union + tenure:union + idcode,
                clusters = idcode,
                data = nlswork)
summary(m3)
```
- why NAs in F-statistic?
`- directly set fixed effects variable: nice since it also provides cleaner output and acc. to manual should be faster

```{r}
m3fe <- lm_robust(ln_wage ~ age + tenure + union + tenure:union,
                  clusters = idcode,
                  fixed_effects = ~idcode,
                  data = nlswork)
summary(m3fe)
```
- results the same as for `m3`
- but SEs a bit lower than by sandwich/Stata -> different correction used by default (TODO: explain)

```{r}
m3fe_df <- tidy(m3fe)
m3fe_df$std.error.sandwich <-  m1coeffs_cl[coi_indices,2][2:5]
m3fe_df[c('term', 'estimate', 'std.error', 'std.error.sandwich')]
```


- another good thing: no need to drag along vcov matrix
- FE model doesn't work with `margins`:

```{r}
#margins(m3fe, variables = 'tenure', at = list(union = 0:1)) %>% summary()      # doesn't work
```
- this works:

```{r, warning=FALSE}
margins(m3, variables = 'tenure', at = list(union = 0:1)) %>% summary()
```
- produces warnings "In sqrt(var_fit) : NaNs produced"
- SEs smaller than with sandwich
- uses different SE calculation by default (see math. notes https://declaredesign.org/r/estimatr/articles/mathematical-notes.html#lm_robust-notes)
- to achieve same result as with sandwich/lmtest use "stata" SEs:

```{r}
m3stata <- lm_robust(ln_wage ~ age + tenure + union + tenure:union + idcode,
                     clusters = idcode,
                     se_type = 'stata',
                     data = nlswork)
summary(m3stata)
```
```{r, warning=FALSE}
margins(m3stata, variables = 'tenure', at = list(union = 0:1)) %>% summary()
```

## Performance comparison {-}

- performance can be crucial for large datasets
- baseline: lm and sandwich
- `lm.cluster` should have similar performance to lm and sandwich
- three options for `lm_robust`
- for fair comparison: don't calc. CIs (which `lm_robust` by default does)

```{r}
library(microbenchmark)

bench_lm_sandwich <- function() {
  m <- lm(ln_wage ~ age + tenure + union + tenure:union + idcode, data = nlswork)
  vcovmat <- vcovCL(m, cluster = ~idcode)
}

bench_lm_cluster <- function() {
  lm.cluster(ln_wage ~ age + tenure + union + tenure:union + idcode,
                 cluster = 'idcode',
                 data = nlswork)
}

bench_lm_robust1 <- function() {
  lm_robust(ln_wage ~ age + tenure + union + tenure:union + idcode,
            clusters = idcode,
            ci = FALSE,
            data = nlswork)
}

bench_lm_robust2 <- function() {
  lm_robust(ln_wage ~ age + tenure + union + tenure:union + idcode,
            clusters = idcode,
            se_type = 'stata',
            ci = FALSE,
            data = nlswork)
}

bench_lm_robust3 <- function() {
  lm_robust(ln_wage ~ age + tenure + union + tenure:union,
            clusters = idcode,
            fixed_effects = idcode,
            se_type = 'stata',
            ci = FALSE,
            data = nlswork)
}

microbenchmark(bench_lm_sandwich(),
               bench_lm_cluster(),
               bench_lm_robust1(),
               bench_lm_robust2(),
               bench_lm_robust3(),
               times = 30)
```

- specifying `fixed_effects` should speed things up, but in this case it doesn't

- now with CIs:

```{r}
bench_lm_sandwich_ci <- function() {
  m <- lm(ln_wage ~ age + tenure + union + tenure:union + idcode, data = nlswork)
  vcovmat <- vcovCL(m, cluster = ~idcode)
  ci <- coefci(m, cov = vcovmat)
}

bench_lm_robust1_ci <- function() {
  lm_robust(ln_wage ~ age + tenure + union + tenure:union + idcode,
            clusters = idcode,
            ci = TRUE,
            data = nlswork)
}

bench_lm_robust2_ci <- function() {
  lm_robust(ln_wage ~ age + tenure + union + tenure:union + idcode,
            clusters = idcode,
            se_type = 'stata',
            ci = TRUE,
            data = nlswork)
}

microbenchmark(bench_lm_sandwich_ci(),
               bench_lm_robust1_ci(),
               bench_lm_robust2_ci(),
               times = 30)
```

- Stata-type errors seem to be much faster to calculate

## Comparision of results with Stata {-}

TODO

## Conclusion {-}

- sandwich+lmtest / lm.cluster: super careful not to forget to pass the vcov mat!
- better with estimatr: vcov information inside model -> is used correctly by other functions like margins
- nested clusters: not possible with estimatr (?)

