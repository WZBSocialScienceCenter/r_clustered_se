---
title: 'Clustered standard errors with R: Three ways, one result'
author: "Markus Konrad"
date: "4/6/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

TODO

## Data

TODO

```{r, warning=FALSE, error=FALSE}
library(webuse)
library(dplyr)

nlswork_orig <- webuse('nlswork')

nlswork <- filter(nlswork_orig, idcode <= 100) %>%
  select(idcode, year, ln_wage, age, tenure, union) %>%
  filter(complete.cases(.)) %>%
  mutate(union = as.integer(union),
         idcode = as.factor(idcode))
str(nlswork)
```


```{r}
head(nlswork)
```

```{r}
summary(nlswork)
```

```{r}
length(unique(nlswork$idcode))
```


```{r}
summary(as.integer(table(nlswork$idcode)))
```

```{r}
table(nlswork$union)
```

## Fixed-effects model, not adjusting for clustered observations

```{r}
m1 <- lm(ln_wage ~ age + tenure + union + tenure:union + idcode,
         data = nlswork)
summary(m1)
```
Only show coeff. of interest (exclude FE):

```{r}
m1coeffs_std <- data.frame(summary(m1)$coefficients)
coi_indices <- which(!startsWith(row.names(m1coeffs_std), 'idcode'))
m1coeffs_std[coi_indices,]
```
heatmap of excerpt of variance-covariance matrix

```{r}
heatmap(vcov(m1)[1:30, 1:30], Rowv = NA, Colv = NA)
```
## Stata

TODO

## Option 1: *sandwich* and *lmtest*

- acts on model from `lm`
- `vcov` either takes a vcov mat or a function to calculate a vcov mat from `lm` object; here, use `vcovCL` function from sandwich
- `cluster` takes the variable(s) to cluster on (either as formula or string vector)

```{r, warning=FALSE}
library(sandwich)
library(lmtest)

m1coeffs_cl <- coeftest(m1, vcov = vcovCL, cluster = ~idcode)     # , fix = TRUE ?
m1coeffs_cl[coi_indices,]
```

- calc. 95%-CIs:

```{r}
coefci(m1, parm = coi_indices, vcov = vcovCL, cluster = ~idcode)
```
- important to "drag along" the vcov and cluster parameters, otherwise CIs for unadjusted model are calculated
- here, `tenure` and `union` CIs suddenly do not include zero

```{r}
coefci(m1, parm = coi_indices)
```

- we can also first calculate the vcov mat for clustered SEs and then pass this matrix to all further functions that we need

```{r}
cl_vcov_mat <- vcovCL(m1, cluster = ~idcode)
heatmap(cl_vcov_mat[1:30, 1:30], Rowv = NA, Colv = NA)
```

- this time we pass the vcov matrix
- result is the same

```{r}
m1coeffs_cl2 <- coeftest(m1, vcov = cl_vcov_mat)
m1coeffs_cl2[coi_indices,]
```
- same for CIs:

```{r}
coefci(m1, parm = coi_indices, vcov = cl_vcov_mat)
```

- calculate marginal effects: pass vcov matrix

```{r, warning=FALSE}
library(margins)

margins(m1, vcov = cl_vcov_mat, variables = 'tenure', at = list(union = 0:1)) %>% summary()
```

- forgetting the vcov matrix:

```{r}
margins(m1, variables = 'tenure', at = list(union = 0:1)) %>% summary()
```

## Option 2: `lm.cluster` from *miceadds*

- once again a strange package name
- additional functionality for imputation with *mice* package
- happens to contain a function for clustered SE, `lm.cluster`
- basically does the same as we've done before by using sandwich's `vcovCL` (see source https://github.com/alexanderrobitzsch/miceadds/blob/ca9e54c18e9743280b9a075e6e119fec38693af2/R/lm.cluster.R#L33 and https://github.com/alexanderrobitzsch/miceadds/blob/ca9e54c18e9743280b9a075e6e119fec38693af2/R/lm_cluster_compute_vcov.R#L13)
- only a bit more convenient maybe

```{r, warning=FALSE}
library(miceadds)

m2 <- lm.cluster(ln_wage ~ age + tenure + union + tenure:union + idcode,
                 cluster = 'idcode',
                 data = nlswork)
m2coeffs <- data.frame(summary(m2))
m2coeffs[!startsWith(row.names(m2coeffs), 'idcode'),]
```

- p-value for intercept is different; dunno why
- returned object from `lm.cluster` is a list that contains the `lm` object as `lmres` and the vcov matrix as `vcov`
- again, these objects need to be "dragged along"
- we also need to pass data again via `data = nlswork`

```{r}
margins(m2$lm_res, vcov = m2$vcov, variables = 'tenure', at = list(union = 0:1), data = nlswork) %>% summary()
```
- the result is consistent with our former computations

## Option 3: `lm_robust` from *estimatr*

- reference to DeclareDesign framework
- https://declaredesign.org/r/estimatr/articles/getting-started.html#lm_robust

```{r}
library(estimatr)

m3 <- lm_robust(ln_wage ~ age + tenure + union + tenure:union + idcode,
                clusters = idcode,
                data = nlswork)
summary(m3)
```
- why NAs in F-statistic?
`- directly set fixed effects variable: nice since it also provides cleaner output and acc. to manual should be faster

```{r}
m3fe <- lm_robust(ln_wage ~ age + tenure + union + tenure:union,
                  clusters = idcode,
                  fixed_effects = ~idcode,
                  data = nlswork)
summary(m3fe)
```
- results the same as for `m3`
- 

- another good thing: no need to drag along vcov matrix
- FE model doesn't work with `margins`:

```{r}
margins(m3fe, variables = 'tenure', at = list(union = 0:1)) %>% summary()      # doesn't work
```
- this works:

```{r, warning=FALSE}
margins(m3, variables = 'tenure', at = list(union = 0:1)) %>% summary()
```
- produces warnings "In sqrt(var_fit) : NaNs produced"
- SEs smaller than with sandwich
- uses different SE calculation by default (see math. notes https://declaredesign.org/r/estimatr/articles/mathematical-notes.html#lm_robust-notes)
- to achieve same result as with sandwich/lmtest use "stata" SEs:

```{r}
m3stata <- lm_robust(ln_wage ~ age + tenure + union + tenure:union + idcode,
                     clusters = idcode,
                     se_type = 'stata',
                     data = nlswork)
summary(m3stata)
```
```{r, warning=FALSE}
margins(m3stata, variables = 'tenure', at = list(union = 0:1)) %>% summary()
```

## Performance comparison

- performance can be crucial for large datasets
- baseline: lm and sandwich
- `lm.cluster` should have similar performance to lm and sandwich
- three options for `lm_robust`
- for fair comparison: don't calc. CIs (which `lm_robust` by default does)

```{r}
library(microbenchmark)

bench_lm_sandwich <- function() {
  m <- lm(ln_wage ~ age + tenure + union + tenure:union + idcode, data = nlswork)
  vcovmat <- vcovCL(m, cluster = ~idcode)
}

bench_lm_cluster <- function() {
  lm.cluster(ln_wage ~ age + tenure + union + tenure:union + idcode,
                 cluster = 'idcode',
                 data = nlswork)
}

bench_lm_robust1 <- function() {
  lm_robust(ln_wage ~ age + tenure + union + tenure:union + idcode,
            clusters = idcode,
            ci = FALSE,
            data = nlswork)
}

bench_lm_robust2 <- function() {
  lm_robust(ln_wage ~ age + tenure + union + tenure:union + idcode,
            clusters = idcode,
            se_type = 'stata',
            ci = FALSE,
            data = nlswork)
}

bench_lm_robust3 <- function() {
  lm_robust(ln_wage ~ age + tenure + union + tenure:union,
            clusters = idcode,
            fixed_effects = idcode,
            se_type = 'stata',
            ci = FALSE,
            data = nlswork)
}

microbenchmark(bench_lm_sandwich(),
               bench_lm_cluster(),
               bench_lm_robust1(),
               bench_lm_robust2(),
               bench_lm_robust3(),
               times = 30)
```

- specifying `fixed_effects` should speed things up, but in this case it doesn't

- now with CIs:

```{r}
bench_lm_sandwich_ci <- function() {
  m <- lm(ln_wage ~ age + tenure + union + tenure:union + idcode, data = nlswork)
  vcovmat <- vcovCL(m, cluster = ~idcode)
  ci <- coefci(m, cov = vcovmat)
}

bench_lm_robust1_ci <- function() {
  lm_robust(ln_wage ~ age + tenure + union + tenure:union + idcode,
            clusters = idcode,
            ci = TRUE,
            data = nlswork)
}

bench_lm_robust2_ci <- function() {
  lm_robust(ln_wage ~ age + tenure + union + tenure:union + idcode,
            clusters = idcode,
            se_type = 'stata',
            ci = TRUE,
            data = nlswork)
}

microbenchmark(bench_lm_sandwich_ci(),
               bench_lm_robust1_ci(),
               bench_lm_robust2_ci(),
               times = 30)
```

- Stata-type errors seem to be much faster to calculate


## Conclusion

- sandwich+lmtest / lm.cluster: super careful not to forget to pass the vcov mat!
- better with estimatr: vcov information inside model -> is used correctly by other functions like margins
- nested clusters: not possible with estimatr (?)

